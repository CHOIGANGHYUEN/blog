# 추상화

## 분해와 추상화😎

- 분해☀️ : 큰 문제를 해결하기 위한 개본 패러다임 : 분할과 정복

  - 각 하위 문제는 동일한 세부 수준에 있음
  - 각 하위 문제는 독립적으로 해결 가능
  - 하위 문제에 대한 솔루션을 결합해 원래 문제를 해결

- 추상화☀️ : 관련성 있는 속성과 그렇지 않은 속성 분리

  - 문제를 더 간단한 문제로 변환하기 위해 특정 세부 사항을 무시
  - 프로그램 설계 프로세스의 전형
  - 추상화 수준을 정의해 복잡한 구현을 계층화

### 파라미터화에 의한 추상화

- 데이터를 파라미터로 대체하여 데이터의 ID 추상화
- 형식 파라미터를 사용해 계산을 추상화
- 일반성을 달성하는 중요한 수단
- 절차를 일반화하고 더 유용하게 만듦

#### EX

하드 코딩 예시

```java
int arr[] = {1, 2, 3, 4, 5};
int sum = 0;
for(int i = 0; i < 5; i++) {
    sum += arr[i];
}
System.out.println(sum);
```

파라미터화에 의한 추상화 예시

```java
int arr[] = {1, 2, 3, 4, 5};
int sum = calculateSum(arr);
System.out.println(sum);

int calculateSum(int[] arr) {
    int sum = 0;
    for(int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```

### 명세에 의한 추상화

- 구현 세부사항에서 사용자가 의존할 수 있는 동작까지 추상화
- 의존하는 동작을 지원하는 구현에서 모듈을 분리
- 프로시저 본문에 의해 설명된 계산을 추상화
- 두가지 고유 규칙
  1. 프로시저를 실행 한 후 호출이 수행될 때 전제 조건이 유지되면 사후 조건이 유지된다고 가정
     - 프로시저 사용자가 프로시저를 사용하기 위해 프로시저 본문을 볼 필요가 없음
  2. 사후 조건에서 추론 할 수 있는 속성만 가정
     - 관련성이 없는 것으로 추정되는 일부 정보를 생략한다는 것을 분명히함
- 추가 설명🔭
  - 사전조건은 함수나 프로시저에 전달되는 인자값의 조건으로, 이 조건을 만족하지 않으면 함수나 프로시저는 제대로 작동하지 않습니다.
  - 사후조건은 함수나 프로시저가 반환하는 값의 조건으로, 이 조건을 만족해야만 함수나 프로시저가 제대로 작동한 것으로 간주됩니다.
  - 사후조건에서 추론 가능한 속성만 가정하면, 사용자는 함수나 프로시저의 내부 동작 방식을 몰라도 정확하게 사용할 수 있습니다. 예를 들어, 정렬 알고리즘이 어떻게 작동하는지 몰라도, 정렬 알고리즘이 제대로 동작했는지 여부를 반환된 값으로 판단할 수 있습니다.
- 프로시저란 무엇인가요?
  - 프로시저는 함수와 비슷하지만 반환값이 없거나 void를 반환합니다. 예를 들면 정렬 알고리즘에서 배열을 받아 배열을 리턴하면 함수이고, 배열을 직접 수정하면 프로시저입니다!
