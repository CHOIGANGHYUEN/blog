## 4장 데이터베이스 구조의 원리

### 4.1 데이터 파일

#### 4.1.1 페이지와 익스텐트

![Alt text](image.png)
데이터 베이스를 구성하는 데이터 파일은 내부적으로 **페이지**라고 하는 8kb의 논리단위로 구분되어 사용된다.

페이지는 테이블 등의 오브젝트에 저장된 데이터으 참조와 변경 시 최소 논리 I/O 단위로 사용된다.

- 페이지
  - 8kb의 논리단위
  - 최소 논리 I/O단위로 사용(데이터 참조 / 변경)

오브젝트에 새로운 영역을 할당해야 하는 경우에는 페이지가 아닌 **익스텐트**라는 단위가 사용된다.

익스텐트는 8kb의 페이지가 8개로 구성된 단위이다.

테이블에 할당된 모든 페이지에 빈 용량이 없어지면 테이블에는 새로운 익스텐트가 할당된다.

- 익스텐트
  - 8개의 페이지로 구성
  - 오브젝트에 새로운 영역을 할당할 때

#### 4.1.2 단일 익스텐트와 혼합 익스텐트

익스텐트에는 하나의 오브젝트에 8페이지 모두를 점유하는 **단일 익스텐트**와 복수의 오브젝트에서 공유하는 **혼합 익스텐트** 2종류가 있다.

![Alt text](image-1.png)

- 혼합 익스텐트
  - 혼합 익스텐트 유무 검색
  - 빈 페이지 유무 확인 후 할당
  - 작업량이 많아 할당이 빈번하면 처리 시간이 지연되는 경우가 있다.
- 단일 익스텐트
  - 모든 페이지가 하나의 오브젝트에 링크
  - 단순히 그 안의 페이지를 할당하면 됨.
  - 오브젝트의 사이즈가 1페이지보다 커지지 않는다면 7페이지가 낭비 됨.

SQL 서버 2014까지는 혼합 익스텐트가 디폴트였으나 SQL 서버 2016 부터는 단일 익스텐트가 디폴트가 되었다.

```SQL
-- ALTER DATABASE 스테이트먼트에서, MIXED_PAGE_ALLOCATION 옵션으로 디폴트 동작을 변경 할 수 있다.

-- 혼합 익스텐트 할당을 무효화(디폴트 설정)
ALTER DATABASE AdventureWorks2012
SET ALLOW_SNAPSHOT_ISOLATION OFF;
GO;

-- 혼합 익스텐트 할당을 유효화
ALTER DATABASE AdventureWorks2012
SET ALLOW_SNAPSHOT_ISOLATION ON;
GO;
```

#### 4.1.3 페이지의 종류

데이터 파일 내의 페이지는 다음 중 어느 쪽인가를 저장하는 용도로 사용된다.( 관리 정보 저장용 페이지는 제외)

- IN_ROW_DATA : 데이터 또는 인덱스를 저장
- LOB_DATA : 라지 오브젝트(text, ntext, image, xml, varchar(max), nvarchar(max), varbinary(max))를 저장
- ROW_OVERFLOW_DATA : 페이지 상한인 8KB를 넘는 가변 길이 칼럼의 데이터를 저장

#### 4.1.4 페이지의 배치

데이터 파일의 대부분의 페이지는 데이터와 인덱스 키를 저장하는데 사용 되지만, 극히 소수의 관리 정보만을 저장한 페이지가 있다.

관리 정보만 저장한 페이지는 데이터베이스를 효율적으로 관리하기 위해 데이터베이싀 할당 정보를 보관하고 있다.

- 관리 정보 페이지
  - 관리 정보만 저장
  - 데이터베이스 효율적인 관리

**GAM**</br>
8kb의 페이지 내 각 비트가 익스텐트의 상황을 나타낸다. 만약 비트의 값이 1을 나타내는 경우는 대응하는 데이터베이스 내의 익스텐트가 할당되어 있지 않았음을 나타낸다. 단일 익스텐트에 할당되면 비트의 값은 0으로 설정된다.

1개의 GAM 페이지에서 64000익스텐트분(4GB)의 상태를 관리할 수 있다. SQL 서버가 오브젝트에 익스텐트를 새로 할당하는 경우에는 이 페이지를 참조해서 효율적으로 미사용 페이지의 익스텐트를 찾아낼 수 있다.

- 익스텐트가 할당 됨 : 0
- 익스텐트가 할당 됨X : 1

![Alt text](image-2.png)

**SGAM**</br>
이것은 혼합 익스텐트의 상황을 나타내느 페이지.
GAM과 마찬가지로 8KB분의 각 비트가 대응하는 익스텐트의 상황을 나타낸다. 1이 설정되어 있는 경우는 혼합 익스텐트로 할당되어 빈 페이지가 존재하는 것을 나타낸다.

0인 경우엔 빈 페이지가 존재하지 않지만, 혼합 익스텐트로 할당되어 있지 않음을 나타낸다.

![Alt text](image-3.png)

**PFS(Page Free Space**</br>
8kb페이지에 각 바이트가 대응하는 페이지의 상황을 나타내고 8000 페이지 분의 정보를 저장한다.

페이지 사용, 미사용 같은 정보를 추가하면 페이지 사용률도 확인이 가능하다.

PFS의 정보를 사용해 새로운 데이터를 저장하기 위한 페이지를 찾는다.

다만 인덱스 페이지는 인덱스 키 값에 따라 저장해야할 장소가 정해진다.

따라서 PFS는 힙이나 Text/Iamge 데이터의 저장 장소 검색을 위해서만 사용된다.

![Alt text](image-4.png)

**IAM(Index Allocation Map)**</br>

클러스터화 인덱스, 비클러스터화 인덱스 및 히프와 각각의 오브젝트에 사용되는 익스텐트를 링크하기 위해 사용되는 8kb의 페이지이다. 1개의 IAM(Index Allocation Map)으로 64000익스텐트분(4GB) 정보를 관리 할 수 있다.

인덱스 등 사이즈가 4GB를 넘는 경우는 2개째 IAM이 할당 된다. 쌍방의 IAM은 상호의 링크 정보를 갖고 있다.

![Alt text](image-5.png)

#### CHAT GPT

여기서 언급된 "GAM", "SGAM", "PFS", "IAM"은 SQL 서버의 데이터 저장 및 관리에 사용되는 시스템 페이지에 관한 것입니다. 이들은 데이터베이스에서 데이터의 저장 및 관리를 최적화하기 위해 사용되는 메커니즘을 나타냅니다.

1. **GAM (Global Allocation Map)**:

   - SQL 서버에서 8KB 크기의 페이지를 사용하여 각 비트가 데이터베이스 내의 익스텐트(데이터 저장 단위)의 상태를 나타냅니다.
   - 비트 값이 1이면 해당 익스텐트가 할당되지 않았음을, 0이면 할당되었음을 나타냅니다.
   - 하나의 GAM 페이지는 64,000 익스텐트(약 4GB)의 상태를 관리할 수 있습니다.
   - 새로운 익스텐트를 할당할 때 SQL 서버는 이 페이지를 참조하여 효율적으로 사용 가능한 익스텐트를 찾습니다.

2. **SGAM (Shared Global Allocation Map)**:

   - SGAM은 혼합 익스텐트의 상태를 나타내는 페이지입니다.
   - GAM과 마찬가지로 8KB 크기의 페이지에서 각 비트가 익스텐트의 상태를 나타냅니다.
   - 비트 값이 1이면 혼합 익스텐트로 할당되어 빈 페이지가 있음을, 0이면 혼합 익스텐트로 할당되지 않았음을 나타냅니다.

3. **PFS (Page Free Space)**:

   - 8KB 페이지에서 각 바이트가 대응하는 페이지의 상태를 나타내며, 8,000 페이지 분의 정보를 저장합니다.
   - 페이지의 사용 여부 및 사용률을 나타내어 새로운 데이터 저장을 위한 페이지를 찾는 데 사용됩니다.
   - PFS는 주로 힙이나 Text/Image 데이터의 저장 장소 검색에 사용됩니다.

4. **IAM (Index Allocation Map)**:
   - 클러스터화된 인덱스, 비클러스터화된 인덱스 및 힙과 각각의 오브젝트에 사용되는 익스텐트를 매핑하기 위한 8KB 페이지입니다.
   - 하나의 IAM 페이지는 최대 64,000 익스텐트(약 4GB)의 정보를 관리할 수 있습니다.
   - 인덱스 크기가 4GB를 초과하는 경우 추가 IAM 페이지가 할당되며, 각 IAM 페이지는 서로 연결되어 있습니다.

이러한 페이지들은 데이터베이스의 효율적인 공간 관리 및 데이터 접근을 위해 중요한 역할을 합니다.

### 4.2 트랜잭션 로그 파일

**트랜잭션 로그**는 SQL서버가 관리하는 오브젝트로는 예외적으로 8KB라는 페이지 단위가 사용되지 않는다. 트랜잭션 로그 레코드의 사이즈는 실행된 오퍼레이션에 따라 4~60KB의 범위에서 변화한다.

- 트랜잭션 로그
  - 8KB 페이지 단위 X
  - 4~60KB 범위의 트랜잭션 로그 레코드 사이즈를 갖는다.

#### 4.2.1 가상 로그 파일

SQL 서버는 트랜잭션 로그 파일을 다시 여러 개의 가상 로그 파일이라 불리는 단위로 분할해서 사용한다. 트랜잭션 로그 파일 내의 각 가상 로그 파일을 최소 단위로 해서 영역의 '사용 중', '미사용' 같은 상태값이 관리된다.

또한 로그 파일의 축소와 확장 등도 가상 로그 파일을 하나의 단위로 해서 실행된다.

![Alt text](image-6.png)

가상 로그 파일의 사이즈는 SQL서버에 의해서 결정되기 떄문에 유저가 직접 변경하는 등의 관리는 불가능하다. 일반적으로 데이터베이스를 작성한 단계에서 트랜잭션 로그 파일에 작은 사이즈를 지정하면 작은 사이즈의 가상 로그파일이 할당된다. 반대로 큰 사이즈의 트랜잭션 로그파일은 큰 사이즈의 가상 로그 파일로 분할된다.

또한 트랜잭션 로그 파일의 확장 사이즈로서 작은 값이 지정된 경우 파일의 확장이 발상될 때마다 작은 사이즈의 가상 로그 파일이 추가된다. 작은 가상 로그파일로 분할된 로그 파일에 트랜잭션 로그가 축적 되고, 그 결과 확장이 반복 됐다고 하자. 결과적으로 로그 파일은 매우 많은 수의(작은 사이즈) 가상 로그 파일로 구성된다.

![Alt text](image-7.png)

SQL 서버는 다수의 가상 로그 파일의 관리(스테이터스의 업데이트 등)가 필요하며, 그에 따른 오버헤드는 퍼포먼스에 악영향을 미치는 경우가 있다.

그러한 상황을 피하기 위해 데이터베이스를 정의하는 단계에서 필요 최대한으로 생각되는 사이즈를 트랜잭션 로그 파일에 할당할 것을 권장한다.

- 트랜잭션 로그 파일(소) -> 부하 커짐

  - 새로운 로그 파일을 확장 할 때 마다 작은 로그 파일들이 생성되어 여러 상태 관리에 대한 부하가 커진다.

- 트랜잭션 로그 파일(대) -> 부하 작음
  - 큰 로그 파일들만 생성되며, 여러 상태 관리에 대한 부하가 작다.

### 4.3 데이터베이스 파일 내의 액세스 수법

데이터베이스 내의 각 오브젝트에 엑세스 하는 방법과 순서는 쿼리 옵티마이저라 불리는 컴포넌트가 결정한다. 옵티마이저에 따라서 가장 효율적으로 데이터에 엑세스하기 위한 수단(최적의 인덱스 선택과 테이블의 결합 방법/순서 등)을 결정하고, 그 결정에 기초한 순서대로 테이블 등에 저장된 데이터를 취득한다.

쿼리 옵티마이저의 동작 자체도 매우 흥미롭지만, 여기서는 우선 쿼리 옵티마이저가 데이터에 엑세스하는 수단을 결정한 후에 어떤 알고리즘으로 실제 데이터를 취득하는지를 소개한다.

인덱스가 사용되는 경우 각 인덱스 페이지는 동일 계층의 앞 페이지와 다음 페이지의 포인터를 각각 갖고 있다. 또한 인덱스의 각 계층도 링크 리스트로 링크 되어 있다. 때문에, 가령 목적하는 데이터를 취득하기 위해 인덱스를 스캔해야 하는 경우 매우 심플한 알고리즘으로 데이터를 취득 할 수 있다. 스캔 시작 페이지를 인덱스 페이지 계층의 상위에서 하위로 링크 리스트를 사용해서 특정한다. 다음으로 앞 페이지 또는 다음 페이지의 포인터를 사용해서 스캔 시작 페이지부터 스캔 종료 지점까지 이동하면서 데이터를 취득하면 된다.

![Alt text](image-8.png)

- 인덱스 페이지는 상위, 하위 계층과 링크되어 있고, 앞 페이지와 다음 페이지가 링크되어있다.
- 심플한 알고리즘이 사용 가능하다

인덱스가 사용되지 않는 경우 히프 테이블의 각 데이터 페이지는 앞 페이지 및 다음 페이지의 포인터를 갖고 있지 않다. 때문에 개별 데이터 페이지 만으로는 상호의 관련성을 전혀 파악할 수 없다.

![Alt text](image-9.png)

- 단순 페이지라면, 페이지 간에 상호 관계를 전혀 알 수 없다.

그러면 그런 상황에서 테이블 내의 전 건을 스캔할 필요가 있는 경우 어떤 순서를 생각 할 수 있을까?

히프를 구성하고 있는 각 데이터 페이지에는 정보가 없기 때문에 관리정보를 저장하고 있는 페이지를 의존하는 수 밖에 달리 방법이 없다. 이 경우는 앞서 말한 IAM이 가장 효과를 발휘한다. IAM의 각 비트를 확인하면 히프가 사용되고 있는 모든 익스텐트를 알 수 있다. 다음은 각 익스텐트에 저장되어 있는 데이터 페이지를 순차 참조 해서 익스텐트 내의 페이지를 스캔한다. 하나의 익스텐트 내 모든 페이지의 스캔이 종료하면 IAM의 정보에 기초해서 다음 익스텐트로 이동하고, 각 데이터 페이지에 엑세스하는 동작을 반복해서 히프 테이블을 스캔할 수 있다.

![Alt text](image-10.png)

#### CHAT GPT

SQL 서버에서 히프(Heap) 구조를 가진 테이블의 모든 데이터를 스캔할 때의 과정을 이해하기 쉽게 설명드리겠습니다. 히프 구조는 인덱스가 없는 테이블로, 데이터가 순차적이거나 정렬된 방식으로 저장되어 있지 않습니다. 이런 상황에서 전체 데이터를 스캔하기 위해 IAM (Index Allocation Map) 페이지가 중요한 역할을 합니다.

1. **IAM 페이지 사용**:

   - IAM 페이지는 테이블에 할당된 모든 익스텐트(데이터 저장 단위)의 정보를 가지고 있습니다.
   - 데이터 스캔을 시작하기 전에, IAM 페이지를 참조하여 테이블에 할당된 모든 익스텐트의 위치를 파악합니다.

2. **익스텐트 순차 접근**:

   - IAM에서 파악한 정보에 따라 각 익스텐트에 순차적으로 접근합니다.
   - 각 익스텐트에는 여러 데이터 페이지가 포함될 수 있으며, 이 페이지들에 테이블의 실제 데이터가 저장되어 있습니다.

3. **데이터 페이지 스캔**:

   - 익스텐트 내의 각 데이터 페이지를 차례대로 스캔합니다.
   - 한 익스텐트의 모든 페이지를 스캔한 후에는 IAM의 정보를 기반으로 다음 익스텐트로 이동합니다.

4. **전체 테이블 스캔 완료**:
   - 이 과정을 반복하여 테이블에 할당된 모든 익스텐트의 모든 데이터 페이지를 스캔합니다.
   - 이렇게 하면 테이블의 모든 데이터를 순차적으로 읽을 수 있습니다.

히프 테이블에서 전체 데이터 스캔을 하는 과정은 인덱스가 없기 때문에 더 많은 시간과 자원이 소요될 수 있습니다. 이는 데이터를 저장하거나 검색하는 효율성이 중요한 경우에 고려해야 할 중요한 요소입니다.

### 데이터 베이스 파일의 관리

데이터베이스 파일에는 관리를 숩게 하기 위해 준비된 수만흔 프로퍼티를 설정 할 수 있다. 프로퍼티군 중에서 가장 일반적인 것 중 하나에 자동 확장이 있다. 데이터 파일과 로그 파일이 가득 찼을때 자동으로 파일 사이즈를 확장해주는 편리한 기능이지만, 설정 내용에 따라서는 생각지 않은 문제를 초래하기 때문에 소개한다.

#### 4.4.1 원인 불명의 데이터베이스 확장 실패

각 데이터 베이스 파일의 자동 확장 프로퍼티를 디폴트 상태로 설정해서 운용한 결과 디스크의 빈 용량은 충분한데도 다음과 같은 오류가 일어나서 대처하기 곤란한 경우가 있다,

```
에러 : 1105
중요도 레벨 : 17
메시지 :'Default' 파일 그룹이 가득 찼으므로 데이터베이스 'db1'에 오브젝트 'table1'의 영역을 할당하지 못했습니다.
```

사실 데이터베이스의 각 파일을 자동 확장하는 처리에는 내부적인 타임아웃 값이 설정되어 있다. 그 값은 30초이며 변경은 불가능하다. 또한 실제로 디스크의 빈 용량이 부족해 파일의 자동 확장이 실패한 경우도 빈 용량이 충분히 남아 있는데도 불구하고 타임아웃이 발생한 경우도 같은 오류가 발생한다.

또한 이 문제는 어느 시점 까지는 문제없이 운용되던 시스템에서 갑자기 문제가 일어나는 경향이 있다. 이것은 각 데이터베이스 파일 확장 사이즈의 설정에 원인이 있다. 디폴트 설정에서는 파일의 확장 사이즈는 '10%'로 되어있다. 100MB의 데이터 파일이 용량 부족에 의해서 확장될 때는 10MB가 추가 된다. 그런 작은 사이즈의 경우는 '10%'라는 값은 언뜻 무해한 것 처럼 보이지만, 가령 그것이 쌓여서 500GB에 도달한 파일은 어떨까?

500GB의 10%라고 하면 50GB이다. 디스크의 속도에 따라 다르기도 하지만 50GB의 파일 확장을 30초 이내에 완료하는 것은 대다수의 경우에는 실패한다. 따라서 드라이브에 100GB의 빈 용량이 있어도 확장 실패 메시지가 돌아오는 결과가 된다.

- 디스크 자동확장
  - 10%씩 증가한다.
  - 100MB면 10MB이지만 500GB면 50GB인데 대부분 30초 내에 하는 것은 불가능 하다.
  - 출력되는 메시지가 용량 부족과 타임아웃으로 인해 발생하는 경우와 같은 메시지가 출력된다.

#### 4.4.2 SQL서버 2005 이후 개선된 사항

데이터베이스 파일 확장에 관해 너무 많은 문의가 있어 SQL서버 2005부터 몇가지 개선이 있다.

**제로잉의 회피**</br>
SQL 서버 2000까지는 데이터베이스를 작성할 때나 데이터베이스 파일을 확장할 때 반드시 그 파일 내를 제로로 메우고 포맷했다. 이 동작은 **제로잉**이라고 한다. 당연히 제로잉은 파일의 사이즈가 커지면 커질 수록 긴 시간이 필요하다. SQL 서버 2005부터는 서비스 실행 어카운트에 볼륨의 보수 태스크(SE_MANAGE_VOLUMN_NAME) 특권을 부여함으로써, 데이터베이스 작성과 확장 시의 제로잉을 피할 수 있게 됐다. 이로써 파일 확장 처리의 퍼포먼스가 비약적으로 향상했다.

![Alt text](image-11.png)

**디폴트 설정의 재검토**</br>
SQL 서버 2000까지는 10%로 설정되었던 파일의 작동 확장 프로퍼티가 10MB로 변경됐다. 이로써 자동 확장 프로퍼티에 주의하지 않은 사용자가 뜻하지 않게 용량 부족 오류에 직면하게 된다.

**이상적인 설정**</br>
데이터 파일 확장 실패에 대처하는 몇 가지 방법이 SQL 서버 2005에서 도입됐지만, 실제 운용 환경에서 일상적으로 데이터 파일의 자동 확장이 빈번하게 발생하는 것은 바람직 하지 않다. 자동확장이 반복되는 배경에는 데이터베이스에 추가되는 데이터 증가율을 제대로 파악하지 못했기 때문인데, 그것은 시스템의 안정 운용을 위협하는 요인이 된다. 따라서 항상 시스템이 필요한 파일 용량을 정확하게 파악하고 파일 확장이 필요한 경우에는 계획적으로 수동으로 실행하는 것이 이상적이다. 자동 확장은 어디까지나 긴급 상황에 대비하는 방법으로 사용할 것을 권한다.

- 제로잉
  - 확장된 파일을 0으로 메꿈으로 인해, 파일 사이즈가 클 때, 확장에 오랜 시간이 걸렸음
  - 볼륨의 보수 태스크 권한 부여로 해결
- 디폴트 설정의 재검토
  - 10% 확장을 10MB로 변경
  - 용량 부족에 시달리는 문제 발생
- 이상적인 설정
  - 시스템이 필요한 파일을 정확히 계산
  - 부득이하게 파일 확장이 필요한 경우 수동으로 실행
  - 자동 확장은 긴급상황 대비용으로 사용하는게 권장됨.

### 4.5 데이터의 효율적인 저장 방법

일반적으로 데이터베이스에 축적되는 데이터는 날로 늘어난다. 증가하는 데이터에 대한 근본적인 대처 방법으로 데이터의 운용 방침 확립과 오래된 데이터의 아카이브 등이 필수이다. 그러나 그런 대처의 필요성을 가능한 낮추는 효율적인 데이터 저장방법이 SQL 서버 2005 이후에 차츰 구현되고 있다.

#### 4.5.1 NTFS 파일 압축의 사용

SQL 서버 2005부터 데이터베이스 파일 안에서 읽어들이기 전용으로 설정된 파일그룹을 NTFS 파일에 압축 할 수 있게 됐다. NTFS 파일을 압축하려면 익스플로러나 COMPACT 커맨드를 사용한다. 다만 다음의 점에 주의해야 한다.

- 압축하는 파일 그룹에 읽기 전용(READ_ONLY)프로퍼티를 설정할 필요 가 있다.
- 프라이머리 파일 그룹(.mdf 파일이 포함되어 있다.)과 로그 파일은 압축할 수 없다.
- 다만 읽기 전용 데이터베이스에서는 프라이머리 파일 그룹도 압축할 수 있다.

#### 4.5.2 VARDECIMAL 형

VARDECIMAL형은 DECIMAL형의 저장 영역을 보다 효율적으로 사용하기 위해 SQL 서버 2005 SP2 이후에 구현된 기능이다. DECIMAL형 열은 모든 행에서 테이블의 정의 시에 설정된 영역을 확보한다. 그러나 저장되는 수치에는 크게 편차가 있는 경우도 많아 10자릿수 분을 준비한 경우라도 행 전체 중 80% 이상이 5자릿수 이하인 일도 적지 않다.

만약 테이블의 사이즈가 거대해진 경우 사용되지 않는 자릿수분의 영역을 확보하지 않으면 디스크 사용량을 크게 줄 일 수 있다.

그런 경우에 VARDECIMAL형은 매우 효과적이다. VARDECIMAL형을 사용하면 실제의 값을 추가해서 2바이트만 사용된다. 이로써 효율적인 실수 데이터의 저장이 가능하다

- Enterprice, Developer, Evaluation 각 에디션에서 사용 가능
- 데이터 형으로써 테이블 정의 시에 지정하는게 아니라 데이터베이스의 프로퍼티로 설정한다.
- CPU의 사용률이 증가할 가능성이 있다.
- 시스템 데이터베이스(master, msdb, model, tempdb)에는 vardecimal을 설정 할 수 없다.

#### 4.5.3 데이터 압축

SQL 서버 2008 이후에서는 테이블 별로 데이터를 압축하는 것이 가능하다. 테이블 내의 페이지 단위 또는 행 단위로 데이터를 압축할 수 있다. 이로써 필요한 스토리지의 사이즈를 절약할 수 있는 동시에 I/O수를 줄여 퍼포먼스 향상을 기대할 수 있다.

#### 4.5.4 백업 압축

SQL 서버 2008 이후에는 데이터베이스의 백업을 취득할 때 백업 파일을 압축하는 것이 가능하다. 이로써 백업 파일의 사이즈 축소 및 I/O 수의 삭감에 의한 백업/복원 시간이 단축 된다.

### 4.6 4장 정리

- 데이터 베이스 구조의 상세
- 관리상의 주의사항
- 데이터의 효율적인 저장 방법

데이터베이스를 구성하는 데이터 파일의 내부 구조는 8KB의 페이지 구성을 기본적으로 얼마나 심플하게 관리하느냐를 추구한 결과가 현재의 형태라고 할 수 있다. 한편으로 로그 파일에서는 8KB 페이지의 개념을 사용하지 않고 트랜잭션 로그 역할을 최대한 발휘하는 아키텍처가 도입되어 있는 점은 SQL 서버 디자인의 유연성을 나타내는 것이기도 하다.
