# Adapter패턴

어댑터 패턴(적응자 패턴), 래퍼 패턴

- 배경
  - 재사용성을 목표로 개발한 툴킷도 실제 재 사용성을 발휘하지 못하는 경우
  - 응용 프로그램이 요청하는 인터페이스와 투킷에 정의된 인터페이스가 일치하지 않는 경우
- 해법
  - 이미 개발된 인터페이스를 수정 할 수 없는 경우, 구현을 사옥하거나, 집합을 이용해 어댑터 객체 구현
- 활용
  - 기존 클래스를 사용해야하나 인터페이스가 수정되어야 하는 경우
  - 만들어진 것을 재사용하고자 하나 재사용 가능한 라이브러리를 수정할 수없는 경우
  - 서브 클래스들의 상속을 통해 인터페이스를 개조하는것이 어려운경우.

# 템플릿 메소드 패턴

- 배경

  - 정의된 프레임워크 내에서 동일한 타입의 객체가 다른 방식의 연산을 수행해야 하는 경우
  - 구체적인 구현이 달라 클래스를 따로 만들지만 기본적인 기능이 같다.

- 해법

  - 객체의 연산에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적인 처리는 서브클래스 쪽으로 미룬다.

- 활용
  - 알고리즘 중 변하지 않는 부분을 한번 정의하고, 다양해 질 수 있는 부분은 서브클래스에서 정의할 수 있도록 넘겨줄때
  - 서브 클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둬 코드 중복을 피하고자 할때
  - 서브클래스의 확장을 제어

# Adapter패턴

어댑터 패턴(적응자 패턴), 래퍼 패턴

- 배경
  - 재사용성을 목표로 개발한 툴킷도 실제 재 사용성을 발휘하지 못하는 경우
  - 응용 프로그램이 요청하는 인터페이스와 투킷에 정의된 인터페이스가 일치하지 않는 경우
- 해법
  - 이미 개발된 인터페이스를 수정 할 수 없는 경우, 구현을 사옥하거나, 집합을 이용해 어댑터 객체 구현
- 활용
  - 기존 클래스를 사용해야하나 인터페이스가 수정되어야 하는 경우
  - 만들어진 것을 재사용하고자 하나 재사용 가능한 라이브러리를 수정할 수없는 경우
  - 서브 클래스들의 상속을 통해 인터페이스를 개조하는것이 어려운경우.

# 템플릿 메소드 패턴

- 배경

  - 정의된 프레임워크 내에서 동일한 타입의 객체가 다른 방식의 연산을 수행해야 하는 경우
  - 구체적인 구현이 달라 클래스를 따로 만들지만 기본적인 기능이 같다.

- 해법

  - 객체의 연산에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적인 처리는 서브클래스 쪽으로 미룬다.

- 활용
  - 알고리즘 중 변하지 않는 부분을 한번 정의하고, 다양해 질 수 있는 부분은 서브클래스에서 정의할 수 있도록 넘겨줄때
  - 서브 클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둬 코드 중복을 피하고자 할때
  - 서브클래스의 확장을 제어
